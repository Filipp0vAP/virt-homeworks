# Домашнее задание к занятию "6.6. Troubleshooting"

## Задача 1

Перед выполнением задания ознакомьтесь с документацией по [администрированию MongoDB](https://docs.mongodb.com/manual/administration/).

Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD операция в MongoDB и её 
нужно прервать. 

Вы как инженер поддержки решили произвести данную операцию:
- напишите список операций, которые вы будете производить для остановки запроса пользователя
- предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB


## Ответ

В первую очередь необходимо найти данную операцию - db.currentOp(). 

После можно воспользоваться командой db.killOp(), чтобы прервать выполнение команды. 

Для того, чтобы не попадать в такую ситуацию, возможно использование параметра maxTimeMS() для запросов CRUD в MongoDB.


---

## Задача 2

Перед выполнением задания познакомьтесь с документацией по [Redis latency troobleshooting](https://redis.io/topics/latency).

Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. 
Причем отношение количества записанных key-value значений к количеству истёкших значений есть величина постоянная и
увеличивается пропорционально количеству реплик сервиса. 

При масштабировании сервиса до N реплик вы увидели, что:
- сначала рост отношения записанных значений к истекшим
- Redis блокирует операции записи

Как вы думаете, в чем может быть проблема?

## Ответ

Если я правильно понял, это не совсем проблема, а скорее особенность Redis.

В документации написано следующее:

    if the database has many, many keys expiring in the same second, and these make up at least 25% of the current population of keys with an expire set, Redis can block in order to get the percentage of keys already expired below 25%.

    This approach is needed in order to avoid using too much memory for keys that are already expired, and usually is absolutely harmless since it's strange that a big number of keys are going to expire in the same exact second, but it is not impossible that the user used EXPIREAT extensively with the same Unix time.

Если вкратце и по русски как я это понял: "Если Redis видит что после очистки просроченных ключей их общее количество по прежнему больше 25%, он может заблокировать операции записи до тех пор пока не очистит достаточно ключей чтоб снизить процент просроченных ниже 25%"

Так что никакой проблемы нет, Redis очистится чтобы не занимать память на просроченные ключи и продолжит работу.

---

## Задача 3

Перед выполнением задания познакомьтесь с документацией по [Common Mysql errors](https://dev.mysql.com/doc/refman/8.0/en/common-errors.html).

Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей, в таблицах базы,
пользователи начали жаловаться на ошибки вида:
```python
InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '
```

Как вы думаете, почему это начало происходить и как локализовать проблему?

Какие пути решения данной проблемы вы можете предложить?


## Ответ

Судя по документации у этой ошибки может быть 4 причины:
1. Проблемы с сетью - решение очевидно траблшутить сеть 
2. Истечение таймаута при выполнении большого запроса - решение увеличение таймаута net_read_timeout
3. Нехватка таймаута при первом подключении к серверу - не наш случай точно
4. Если ничего из этого не является причиной, то вероятно проблема с BLOB значениями превышающими max_allowed_packet - как решение соответственно увеличить значение max_allowed_packet

Я бы поступил так в этой ситуации, исключил бы что проблема с сетью, к примеру запустил бы пинг до сервера и наблюдал не будет ли обрыва связи.

Если все ок, то я бы увеличил таймаут net_read_timeout.

Если бы и это не помогло, то тогда бы увеличил значение max_allowed_packet

---

## Задача 4

Перед выполнением задания ознакомьтесь со статьей [Common PostgreSQL errors](https://www.percona.com/blog/2020/06/05/10-common-postgresql-errors/) из блога Percona.

Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с 
большим объемом данных лучше, чем MySQL.

После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:

`postmaster invoked oom-killer`

Как вы думаете, что происходит?

Как бы вы решили данную проблему?

## Ответ

Вероятнее всего БД начинает потреблять больше ОЗУ чем доступно на машине.
Как решение я бы ограничил потребление допустим 32 гб ОЗУ. Этого количества должно хватить для нормальной работы.

Так как в PostgreSQL к сожалению нет отдельной настройки для управлениея выделенной памятью можно воспользоваться этой формулой:
Нужный объем ОЗУ = shared_buffers + (temp_buffers + work_mem) * max_connections

shared_buffers следует установить на 40% от объема памяти, который вы готовы использовать для PostgreSQL, max_connections - на максимальное количество параллельных подключений, которые вы хотите иметь, а temp_buffers и work_mem - чтобы вы не превышали свой бюджет оперативной памяти.

---

### Как сдавать задание

Выполненное домашнее задание пришлите ссылкой на .md-файл в вашем репозитории.

---
